{"meta":{"title":"Mango","subtitle":"","description":"","author":"Mango","url":"https://xiaomango.github.io"},"pages":[{"title":"about","date":"2020-01-05T15:41:08.000Z","updated":"2020-01-05T15:41:08.788Z","comments":true,"path":"about/index.html","permalink":"https://xiaomango.github.io/about/index.html","excerpt":"","text":"","raw":null,"content":null},{"title":"tags","date":"2020-01-05T15:54:01.000Z","updated":"2020-01-05T15:54:01.679Z","comments":true,"path":"tags/index.html","permalink":"https://xiaomango.github.io/tags/index.html","excerpt":"","text":"","raw":null,"content":null}],"posts":[{"title":"MySQL1","slug":"MySQL1","date":"2020-01-05T17:05:54.000Z","updated":"2020-01-05T17:21:09.579Z","comments":true,"path":"2020/01/06/MySQL1/","link":"","permalink":"https://xiaomango.github.io/2020/01/06/MySQL1/","excerpt":"","text":"SQL第一天 数据库的基本概念 MySQL数据库软件 安装 卸载 配置 SQL 数据库的基本概念1. 数据库的英文单词： DataBase 简称 ： DB 2. 什么数据库？ * 用于存储和管理数据的仓库。 3. 数据库的特点： 1. 持久化存储数据的。其实数据库就是一个文件系统 2. 方便存储和管理数据 3. 使用了统一的方式操作数据库 -- SQLMySQL数据库软件1. 安装 * 参照https://dev.mysql.com/doc/refman/8.0/en/windows-installation.html 2. 卸载 1. 去mysql的安装目录找到my.ini文件 * 复制 datadir=&quot;C:/ProgramData/MySQL/MySQL Server 5.5/Data/&quot; 2. 卸载MySQL 3. 删除C:/ProgramData目录下的MySQL文件夹。 3. 配置 * MySQL服务启动 1. 手动。 2. cmd--&gt; services.msc 打开服务的窗口 3. 使用管理员打开cmd * net start mysql : 启动mysql的服务 * net stop mysql:关闭mysql服务 * MySQL登录 1. mysql -uroot -p密码 2. mysql -hip -uroot -p连接目标的密码 3. mysql --host=ip --user=root --password=连接目标的密码 * MySQL退出 1. exit 2. quit * MySQL目录结构 1. MySQL安装目录：basedir=&quot;D:/develop/MySQL/&quot; * 配置文件 my.ini 2. MySQL数据目录：datadir=&quot;C:/ProgramData/MySQL/MySQL Server 5.5/Data/&quot; * 几个概念 * 数据库：文件夹 * 表：文件 * 数据：数据SQL1.什么是SQL？ Structured Query Language：结构化查询语言 其实就是定义了操作所有关系型数据库的规则。每一种数据库操作的方式存在不一样的地方，称为“方言”。 2.SQL通用语法 1. SQL 语句可以单行或多行书写，以分号结尾。 2. 可使用空格和缩进来增强语句的可读性。 3. MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。 4. 3 种注释 * 单行注释: -- 注释内容 或 # 注释内容(mysql 特有) * 多行注释: /* 注释 */ 3. SQL分类 1) DDL(Data Definition Language)数据定义语言 用来定义数据库对象：数据库，表，列等。关键字：create, drop,alter 等 2) DML(Data Manipulation Language)数据操作语言 用来对数据库中表的数据进行增删改。关键字：insert, delete, update 等 3) DQL(Data Query Language)数据查询语言 用来查询数据库中表的记录(数据)。关键字：select, where 等 4) DCL(Data Control Language)数据控制语言(了解) 用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT， REVOKE 等DDL:操作数据库、表1. 操作数据库：CRUD 1. C(Create):创建 * 创建数据库： * create database 数据库名称; * 创建数据库，判断不存在，再创建： * create database if not exists 数据库名称; * 创建数据库，并指定字符集 * create database 数据库名称 character set 字符集名; * 练习： 创建db4数据库，判断是否存在，并制定字符集为gbk * create database if not exists db4 character set gbk; 2. R(Retrieve)：查询 * 查询所有数据库的名称: * show databases; * 查询某个数据库的字符集:查询某个数据库的创建语句 * show create database 数据库名称; 3. U(Update):修改 * 修改数据库的字符集 * alter database 数据库名称 character set 字符集名称; 4. D(Delete):删除 * 删除数据库 * drop database 数据库名称; * 判断数据库存在，存在再删除 * drop database if exists 数据库名称; 5. 使用数据库 * 查询当前正在使用的数据库名称 * select database(); * 使用数据库 * use 数据库名称; 2. 操作表 1. C(Create):创建 1. 语法： create table 表名( 列名1 数据类型1, 列名2 数据类型2, .... 列名n 数据类型n ); * 注意：最后一列，不需要加逗号（,） * 数据库类型： 1. int：整数类型 * age int, 2. double:小数类型 * score double(5,2) 3. date:日期，只包含年月日，yyyy-MM-dd 4. datetime:日期，包含年月日时分秒 yyyy-MM-dd HH:mm:ss 5. timestamp:时间错类型 包含年月日时分秒 yyyy-MM-dd HH:mm:ss * 如果将来不给这个字段赋值，或赋值为null，则默认使用当前的系统时间，来自动赋值 6. varchar：字符串 * name varchar(20):姓名最大20个字符 * zhangsan 8个字符 张三 2个字符 * 创建表 create table student( id int, name varchar(32), age int , score double(4,1), birthday date, insert_time timestamp ); * 复制表： * create table 表名 like 被复制的表名; 2. R(Retrieve)：查询 * 查询某个数据库中所有的表名称 * show tables; * 查询表结构 * desc 表名; 3. U(Update):修改 1. 修改表名 alter table 表名 rename to 新的表名; 2. 修改表的字符集 alter table 表名 character set 字符集名称; 3. 添加一列 alter table 表名 add 列名 数据类型; 4. 修改列名称 类型 alter table 表名 change 列名 新列别 新数据类型; alter table 表名 modify 列名 新数据类型; 5. 删除列 alter table 表名 drop 列名; 4. D(Delete):删除 * drop table 表名; * drop table if exists 表名 ; 客户端图形化工具：SQLYog DML：增删改表中数据1. 添加数据： * 语法： * insert into 表名(列名1,列名2,...列名n) values(值1,值2,...值n); * 注意： 1. 列名和值要一一对应。 2. 如果表名后，不定义列名，则默认给所有列添加值 insert into 表名 values(值1,值2,...值n); 3. 除了数字类型，其他类型需要使用引号(单双都可以)引起来 2. 删除数据： * 语法： * delete from 表名 [where 条件] * 注意： 1. 如果不加条件，则删除表中所有记录。 2. 如果要删除所有记录 1. delete from 表名; -- 不推荐使用。有多少条记录就会执行多少次删除操作 2. TRUNCATE TABLE 表名; -- 推荐使用，效率更高 先删除表，然后再创建一张一样的表。 3. 修改数据： * 语法： * update 表名 set 列名1 = 值1, 列名2 = 值2,... [where 条件]; * 注意： 1. 如果不加任何条件，则会将表中所有记录全部修改。DQL：查询表中的记录* select * from 表名; 1. 语法： select 字段列表 from 表名列表 where 条件列表 group by 分组字段 having 分组之后的条件 order by 排序 limit 分页限定 2. 基础查询 1. 多个字段的查询 select 字段名1，字段名2... from 表名； * 注意： * 如果查询所有字段，则可以使用*来替代字段列表。 2. 去除重复： * distinct 3. 计算列 * 一般可以使用四则运算计算一些列的值。（一般只会进行数值型的计算） * ifnull(表达式1,表达式2)：null参与的运算，计算结果都为null * 表达式1：哪个字段需要判断是否为null * 如果该字段为null后的替换值。 4. 起别名： * as：as也可以省略 3. 条件查询 1. where子句后跟条件 2. 运算符 * &gt; 、&lt; 、&lt;= 、&gt;= 、= 、&lt;&gt; * BETWEEN...AND * IN( 集合) * LIKE：模糊查询 * 占位符： * _:单个任意字符 * %：多个任意字符 * IS NULL * and 或 &amp;&amp; * or 或 || * not 或 ! -- 查询年龄大于20岁 SELECT * FROM student WHERE age &gt; 20; SELECT * FROM student WHERE age &gt;= 20; -- 查询年龄等于20岁 SELECT * FROM student WHERE age = 20; -- 查询年龄不等于20岁 SELECT * FROM student WHERE age != 20; SELECT * FROM student WHERE age &lt;&gt; 20; -- 查询年龄大于等于20 小于等于30 SELECT * FROM student WHERE age &gt;= 20 &amp;&amp; age &lt;=30; SELECT * FROM student WHERE age &gt;= 20 AND age &lt;=30; SELECT * FROM student WHERE age BETWEEN 20 AND 30; -- 查询年龄22岁，18岁，25岁的信息 SELECT * FROM student WHERE age = 22 OR age = 18 OR age = 25 SELECT * FROM student WHERE age IN (22,18,25); -- 查询英语成绩为null SELECT * FROM student WHERE english = NULL; -- 不对的。null值不能使用 = （!=） 判断 SELECT * FROM student WHERE english IS NULL; -- 查询英语成绩不为null SELECT * FROM student WHERE english IS NOT NULL; -- 查询姓马的有哪些？ like SELECT * FROM student WHERE NAME LIKE &#39;马%&#39;; -- 查询姓名第二个字是化的人 SELECT * FROM student WHERE NAME LIKE &quot;_化%&quot;; -- 查询姓名是3个字的人 SELECT * FROM student WHERE NAME LIKE &#39;___&#39;;​ -- 查询姓名中包含德的人 SELECT * FROM student WHERE NAME LIKE &#39;%德%&#39;;​","raw":null,"content":null,"categories":[{"name":"SQL","slug":"SQL","permalink":"https://xiaomango.github.io/categories/SQL/"}],"tags":[]},{"title":"Java基础增强","slug":"Java基础增强","date":"2020-01-05T16:59:05.000Z","updated":"2020-01-05T17:01:07.263Z","comments":true,"path":"2020/01/06/Java基础增强/","link":"","permalink":"https://xiaomango.github.io/2020/01/06/Java%E5%9F%BA%E7%A1%80%E5%A2%9E%E5%BC%BA/","excerpt":"","text":"基础增强1. Junit单元测试 2. 反射 3. 注解Junit单元测试：* 测试分类： 1. 黑盒测试：不需要写代码，给输入值，看程序是否能够输出期望的值。 2. 白盒测试：需要写代码的。关注程序具体的执行流程。 * Junit使用：白盒测试 * 步骤： 1. 定义一个测试类(测试用例) * 建议： * 测试类名：被测试的类名Test CalculatorTest * 包名：xxx.xxx.xx.test cn.itcast.test 2. 定义测试方法：可以独立运行 * 建议： * 方法名：test测试的方法名 testAdd() * 返回值：void * 参数列表：空参 3. 给方法加@Test 4. 导入junit依赖环境 * 判定结果： * 红色：失败 * 绿色：成功 * 一般我们会使用断言操作来处理结果 * Assert.assertEquals(期望的结果,运算的结果); * 补充： * @Before: * 修饰的方法会在测试方法之前被自动执行 * @After: * 修饰的方法会在测试方法执行之后自动被执行反射：框架设计的灵魂* 框架：半成品软件。可以在框架的基础上进行软件开发，简化编码 * 反射：将类的各个组成部分封装为其他对象，这就是反射机制 * 好处： 1. 可以在程序运行过程中，操作这些对象。 2. 可以解耦，提高程序的可扩展性。 * 获取Class对象的方式： 1. Class.forName(&quot;全类名&quot;)：将字节码文件加载进内存，返回Class对象 * 多用于配置文件，将类名定义在配置文件中。读取文件，加载类 2. 类名.class：通过类名的属性class获取 * 多用于参数的传递 3. 对象.getClass()：getClass()方法在Object类中定义着。 * 多用于对象的获取字节码的方式 * 结论： 同一个字节码文件(*.class)在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的Class对象都是同一个。 * Class对象功能： * 获取功能： 1. 获取成员变量们 * Field[] getFields() ：获取所有public修饰的成员变量 * Field getField(String name) 获取指定名称的 public修饰的成员变量 * Field[] getDeclaredFields() 获取所有的成员变量，不考虑修饰符 * Field getDeclaredField(String name) 2. 获取构造方法们 * Constructor&lt;?&gt;[] getConstructors() * Constructor&lt;T&gt; getConstructor(类&lt;?&gt;... parameterTypes) * Constructor&lt;T&gt; getDeclaredConstructor(类&lt;?&gt;... parameterTypes) * Constructor&lt;?&gt;[] getDeclaredConstructors() 3. 获取成员方法们： * Method[] getMethods() * Method getMethod(String name, 类&lt;?&gt;... parameterTypes) * Method[] getDeclaredMethods() * Method getDeclaredMethod(String name, 类&lt;?&gt;... parameterTypes) 4. 获取全类名 * String getName() * Field：成员变量 * 操作： 1. 设置值 * void set(Object obj, Object value) 2. 获取值 * get(Object obj) 3. 忽略访问权限修饰符的安全检查 * setAccessible(true):暴力反射 * Constructor:构造方法 * 创建对象： * T newInstance(Object... initargs) * 如果使用空参数构造方法创建对象，操作可以简化：Class对象的newInstance方法 * Method：方法对象 * 执行方法： * Object invoke(Object obj, Object... args) * 获取方法名称： * String getName:获取方法名 * 案例： * 需求：写一个&quot;框架&quot;，不能改变该类的任何代码的前提下，可以帮我们创建任意类的对象，并且执行其中任意方法 * 实现： 1. 配置文件 2. 反射 * 步骤： 1. 将需要创建的对象的全类名和需要执行的方法定义在配置文件中 2. 在程序中加载读取配置文件 3. 使用反射技术来加载类文件进内存 4. 创建对象 5. 执行方法注解：* 概念：说明程序的。给计算机看的 * 注释：用文字描述程序的。给程序员看的 * 定义：注解（Annotation），也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。 * 概念描述： * JDK1.5之后的新特性 * 说明程序的 * 使用注解：@注解名称​ * 作用分类： ①编写文档：通过代码里标识的注解生成文档【生成文档doc文档】 ②代码分析：通过代码里标识的注解对代码进行分析【使用反射】 ③编译检查：通过代码里标识的注解让编译器能够实现基本的编译检查【Override】 * JDK中预定义的一些注解 * @Override ：检测被该注解标注的方法是否是继承自父类(接口)的 * @Deprecated：该注解标注的内容，表示已过时 * @SuppressWarnings：压制警告 * 一般传递参数all @SuppressWarnings(&quot;all&quot;) * 自定义注解 * 格式： 元注解 public @interface 注解名称{ 属性列表; } * 本质：注解本质上就是一个接口，该接口默认继承Annotation接口 * public interface MyAnno extends java.lang.annotation.Annotation {} * 属性：接口中的抽象方法 * 要求： 1. 属性的返回值类型有下列取值 * 基本数据类型 * String * 枚举 * 注解 * 以上类型的数组 2. 定义了属性，在使用时需要给属性赋值 1. 如果定义属性时，使用default关键字给属性默认初始化值，则使用注解时，可以不进行属性的赋值。 2. 如果只有一个属性需要赋值，并且属性的名称是value，则value可以省略，直接定义值即可。 3. 数组赋值时，值使用{}包裹。如果数组中只有一个值，则{}可以省略 * 元注解：用于描述注解的注解 * @Target：描述注解能够作用的位置 * ElementType取值： * TYPE：可以作用于类上 * METHOD：可以作用于方法上 * FIELD：可以作用于成员变量上 * @Retention：描述注解被保留的阶段 * @Retention(RetentionPolicy.RUNTIME)：当前被描述的注解，会保留到class字节码文件中，并被JVM读取到 * @Documented：描述注解是否被抽取到api文档中 * @Inherited：描述注解是否被子类继承 * 在程序使用(解析)注解：获取注解中定义的属性值 1. 获取注解定义的位置的对象 （Class，Method,Field） 2. 获取指定的注解 * getAnnotation(Class) //其实就是在内存中生成了一个该注解接口的子类实现对象 public class ProImpl implements Pro{ public String className(){ return &quot;cn.itcast.annotation.Demo1&quot;; } public String methodName(){ return &quot;show&quot;; } } 3. 调用注解中的抽象方法获取配置的属性值* 案例：简单的测试框架 * 小结： 1. 以后大多数时候，我们会使用注解，而不是自定义注解 2. 注解给谁用？ 1. 编译器 2. 给解析程序用 3. 注解不是程序的一部分，可以理解为注解就是一个标签","raw":null,"content":null,"categories":[{"name":"java","slug":"java","permalink":"https://xiaomango.github.io/categories/java/"}],"tags":[{"name":"反射和注解","slug":"反射和注解","permalink":"https://xiaomango.github.io/tags/%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/"}]}]}